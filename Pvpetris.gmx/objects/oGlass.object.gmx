<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>io_clear()

adapter = -1
if global.adapter
  adapter = instance_create(0,0,oNetworkAdapter)
  
/* config */
level = real(global.level)
if level &lt; 0 || level &gt; 19
  level = 0
period = 1000 / (level + 1)         //time delay between game ticks
if global.seed != "" {
  random_set_seed(real(global.seed))
  }
  
xLeft1 = 256                //draw coordinated
xRight1 = 608
xLeft2 = 640
xRight2 = 992
firstFigureTrigger = true   //don't send first figure socket
allowedFigures = "ISZOTLJ"  //
sequenceLength = 999        //pre-generated sequence length
sequence = ""               //main
nextSequence = ""           //next sequence for unique cases when number 1000 will be too small (player will survive few levels of "deathscreen" at least)
for (i=0; i&lt;sequenceLength; i++) {
  sequence+= string_char_at(allowedFigures, irandom(string_length(allowedFigures)))
  nextSequence+= string_char_at(allowedFigures, irandom(string_length(allowedFigures)))
  }
sequencePosition = 0        //current figure from seq
lines = 0
ttrlines = 0                //lines burned by ttr
ttrpercent = 100
dry = 0                     //I figure drough
maxdry = 0
pp = 0                      //ppoints
ts = current_time           //timestamp
controlAdd = random_range(1, 999)
control = controlAdd        //control point = lines + ttrlines + pp + random component
controlSequence = sequence
delay = 2000                //current delay
usedSpareDelay = false      //extra delay before fixate

for (var i=0; i&lt;20; i++)    //glass states (0 nothing, otherwise color)
  for (var j=0; j&lt;10; j++)
    arr[i,j] = 0;

clmod = 0
currFig = ""
nextFig = ""
currRot = 0
currClr = 0
currX = 5
currH = 2
for (var i=0; i&lt;4; i++) {   //figure coordinates array
  fh[i] = 0;
  fx[i] = 0;
  }
burn = 0
burnList = 0;
  
dropped = 0                 //score by softdrop
softdrop = false
lineanim = false
tetrisanim = false
lineanimtick = 0
animdelay = 0
nextrequest = false
gameover = false
gameoverAlpha = 1
keydelay = 0
memestring = ""
memetimer = 0
escTimer = 0

oGlassNext()
currH = 0       // reset initial height to zero to show entire figure
delay = 2000    // reset delay to initial value cause oGlassNext recalculates it

oAdapterInit(adapter)

scoresSent = false
scoresRecieved = false
pbScore = 0
wrScore = 0
pbLines = 0
wrLines = 0
var tempnick = string_replace_all(global.plleft, "&amp;", "%26")
tempnick = string_replace_all(tempnick, "?", "%3F")
http_get(domain + restGet + "?name=" + tempnick)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if keyboard_check_released(vk_space) || gamepad_button_check_released(0, gp_start) {
  if gameover {
    if adapter == -1 {
      global.seed = string(random_get_seed() + 1)
      show_debug_message("after restart cleanup")
      instance_destroy()
      instance_create(0, 0, oGlass)
      }
    else if adapter.gameover {
      global.seed = string(random_get_seed() + 1)
      buffer_seek(global.buffer, buffer_seek_start, 0);
      buffer_write(global.buffer, buffer_s8, 19)
      network_send_packet( global.botnet, global.buffer, buffer_tell(global.buffer) );
      show_debug_message("after restart cleanup")
      instance_destroy()
      instance_destroy(adapter)
      instance_create(0, 0, oGlass)
      }
    }
  }

else if keyboard_check_released(vk_escape) || gamepad_button_check_released(0, gp_select) {
  if gameover || escTimer &gt; 0 {
    show_debug_message("quit cleanup")
    instance_destroy()
    instance_destroy(adapter)
    instance_destroy(oAlmiManager)
    instance_destroy(oAlmi)
    if (global.adapter)      network_destroy(global.botnet)
    if (global.server != -1) network_destroy(global.server)
    if (global.client != -1) network_destroy(global.client)
    game_restart()
  } else
    escTimer = 80
}

else if keyboard_check_released(vk_enter) {
  if gameover &amp;&amp; !scoresSent {
    oRestSendScore()
    scoresSent = true
  }
}

if (escTimer &gt; 0)
  escTimer--
if gameover {
  if gameoverAlpha &gt; 0.25
    gameoverAlpha-= 0.005
  if memetimer++ == 2500
    http_get(domain + restSplash)
  exit
  }
if lineanim {
  animdelay-= current_time - ts
  ts = current_time
  if animdelay &lt;= 0
    animdelay = 64
  else
    exit
  if lineanimtick &lt; 5 {
    for (var i=0; i&lt;burn; i++) {
      arr[burnList[i], 4-lineanimtick] = 0
      arr[burnList[i], 5+lineanimtick] = 0
      }
    }
  lineanimtick++
  if lineanimtick &gt;= 6 {
    for (var i=0; i&lt;burn; i++) {
      for (var h=burnList[i]; h&gt;0; h--) {
        for (var j=0; j&lt;10; j++) {
          arr[h,j] = arr[h-1,j]
          }
        }
      for (var j=0; j&lt;10; j++)
        arr[0,j] = 0
      }
    lineanimtick = 0;
    lineanim = false
    tetrisanim = false
    burn = 0
    burnList = 0
    oGlassNext()
    }
  exit
  }

delay-= current_time - ts
if delay &lt; 0 {
  if !softdrop
    delay+= period
  else
    delay = 13      // fine balanced value between softdrop ticks
  if nextrequest
    oGlassNext()
  else
    oGlassGravity()
  }

var shiftDirection = 0
if keyboard_check(vk_left) || gamepad_button_check(0,gp_padl) 
  shiftDirection = -1
else if keyboard_check(vk_right) || gamepad_button_check(0,gp_padr)
  shiftDirection = 1
if shiftDirection != 0 {
  keydelay-= (current_time - ts)
  if keydelay &lt;= 0
    if oGlassShift(shiftDirection)
      keydelay = 80
  }
if keyboard_check_released(vk_left) || keyboard_check_released(vk_right) ||
   gamepad_button_check_released(0, gp_padl) || gamepad_button_check_released(0, gp_padr)
  keydelay = 0

if keyboard_check_pressed(ord("Z")) || gamepad_button_check_pressed(0,gp_face3)
  oGlassRot(-1)
else if keyboard_check_pressed(ord("X")) || gamepad_button_check_pressed(0,gp_face2)
  oGlassRot(1)

if keyboard_check_pressed(vk_down) || gamepad_button_check_pressed(0,gp_padd) {
  softdrop = true
  delay = 0
  }
if keyboard_check_released(vk_down) || gamepad_button_check_released(0, gp_padd)
  softdrop = false

ts = current_time
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//not loaded
if async_load[? "status"] != 0
  exit
  
if string_pos(restSplash, async_load[?'url']) != 0 {
  // getSplash response
  memestring = async_load[? "result"]
} else if (string_pos(restGet, async_load[?'url']) != 0) {
  // getMyBest response
  var response = async_load[? "result"]
  var count = 0
  var tempstr = ''
  var tempchar;
  var strings;
  for (var i = 1; i &lt;= string_length(response); i++) {
    tempchar = string_char_at(response, i)
    if tempchar == ',' {
      strings[count++] = tempstr
      tempstr = ''
    } else
      tempstr+= tempchar
  }
  strings[count] = tempstr
  if !scoresRecieved {          // initial scores request
    pbScore = real(strings[0])
    pbLines = real(strings[1])
    wrScore = real(strings[2])
    wrLines = real(strings[3])
    scoresRecieved = true
    if (adapter != -1) {
      var tempnick = string_replace_all(global.plright, "&amp;", "%26")
      tempnick = string_replace_all(tempnick, "?", "%3F")
      http_get(domain + restGet + "?name=" + tempnick)
    }
  } else {                      // display opponent's pb instead
    wrScore = real(strings[0])
    wrLines = real(strings[1])
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//jonas
draw_sprite_ext(jeff,0,448,0,1,1,0,c_white,0.1)
draw_sprite_ext(jeff,1,832,0,1,1,0,c_white,0.1)

//tetrisanim
if tetrisanim {
  draw_set_alpha(random(0.7))
  draw_set_color(c_white)
  draw_rectangle(256,0,640,672,false)
  }

draw_set_alpha(1)
//draw glasses
for (var i=0; i&lt;20; i++) {
  draw_sprite(sBorder, 0, xLeft1, i*32)
  draw_sprite(sBorder, 0, xRight1, i*32)
  draw_sprite(sBorder, 0, xLeft2, i*32)
  draw_sprite(sBorder, 0, xRight2, i*32)
  }
for (var i=0; i&lt;12; i++) {
  draw_sprite(sBorder, 0, xLeft1 + i*32, 640)
  draw_sprite(sBorder, 0, xLeft2 + i*32, 640)
  }
  
//draw locked figures
var xl = xLeft1 + 32;
for (var i=0; i&lt;20; i++)
  for (var j=0; j&lt;10; j++)
    if arr[i,j] != 0
      draw_sprite_ext(sTile,0,xl+j*32,i*32,1,1,0,arr[i,j],gameoverAlpha)
      
//draw current figure
for (var i=0; i&lt;4; i++)
  draw_sprite_ext(sTile,0,xl+(currX+fx[i])*32, (currH+fh[i])*32, 1,1,0,currClr,gameoverAlpha)
  
//draw next figure
if nextFig != ""
  switch nextFig {
    case "I": draw_sprite_ext(sprite1,0,183,85,1,1,0,c_white,1); break
    case "S": draw_sprite_ext(sprite1,1,183,85,1,1,0,make_color_hsv(42+clmod,255,255),1); break
    case "Z": draw_sprite_ext(sprite1,2,183,85,1,1,0,make_color_hsv(213+clmod,255,255),1); break
    case "O": draw_sprite_ext(sprite1,3,183,85,1,1,0,make_color_hsv(128+clmod,255,255),1); break
    case "T": draw_sprite_ext(sprite1,4,183,85,1,1,0,make_color_hsv(clmod, 255,255),1); break
    case "L": draw_sprite_ext(sprite1,5,183,85,1,1,0,make_color_hsv(85+clmod, 255,255),1); break
    case "J": draw_sprite_ext(sprite1,6,183,85,1,1,0,make_color_hsv(170+clmod,255,255),1); break
    }  

// Stats
draw_set_font(fTetris)
draw_set_color(c_white)
draw_set_halign(fa_right)
draw_set_valign(fa_top)
draw_set_alpha(1)
var xx = xLeft1 - 16
draw_text(xx, 10, "NEXT:")
draw_text(xx, 125, "SCORE:#"+string(pp))
draw_text(xx, 255, "LINES:#"+string(lines))
draw_text(xx, 330, "LEVEL:#"+string(level))
draw_text(xx, 445, "DRY/MAX:#"+string(dry)+" / "+string(maxdry))
draw_text(xx, 525, "TTR:#"+string(ttrpercent))
draw_text_transformed(xx,702,"SEED "+global.seed,0.4,0.4,0)
draw_text_transformed(xx,682,"FIG "+string(sequencePosition),0.4,0.4,0)

if (scoresRecieved) {
  draw_text_transformed(xx,635, "Best score: " + string(pbScore), 0.4,0.4, 0)
  draw_text_transformed(xx,655, "Best lines: " + string(pbLines), 0.4,0.4, 0)
  draw_set_halign(fa_left)
  draw_text_transformed(xRight2+48,635, "Best score: " + string(wrScore), 0.4,0.4, 0)
  draw_text_transformed(xRight2+48,655, "Best lines: " + string(wrLines), 0.4,0.4, 0)
}

draw_set_halign(fa_center)
if gameover {
  draw_set_alpha((0.5-gameoverAlpha)*4)
  draw_text(448,150,"Game over")
  if adapter == -1 || adapter.gameover
    draw_text(448,225,"Press Space#to restart")
  else
    draw_text(448,225,"Wait for player#" + global.plright)
  if !scoresSent
    draw_text_transformed(448,330,"Press Enter#to send score",0.8,0.8,0)
  if memestring != "" {
    draw_text_transformed(448,440, "Don't be bored,#have hello from WordLadder",0.6,0.6,0)
    draw_set_color(irandom(c_white))
    draw_text_transformed(448,500,memestring,0.6,0.6,0)
  }
} else if escTimer &gt; 0 {
  draw_set_alpha(escTimer / 80)
  draw_text_transformed(448,200, "Press Esc to quit",0.6,0.6,0)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
