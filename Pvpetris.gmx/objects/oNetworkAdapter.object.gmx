<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>glass = -1
diffleft = 0
diffright = 0
clleft = 0
clright = 0

sequence = ""
sequencePosition = 0
level = 0
lines = 0
ttrlines = 0
ttrpercent = 100
dry = 0
maxdry = 0
pp = 0

currX = 0
currH = 0
for (var i = 0; i&lt;4; i++) {
  fx[i] = 1
  fh[i] = -1
  }
currClr = c_dkgray
clmod = 0
nextFig = ""

burn = 0
burnList = 0

for (var i=0; i&lt;20; i++)    //glass states (0 nothing, otherwise color)
  for (var j=0; j&lt;10; j++)
    arr[i,j] = 0;
    
lineanim = false
animdelay = 0
lineanimtick = 0
tetrisanim = false

gameover = false
gameoverAlpha = 1
scoresRecieved = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if gameover {
  if gameoverAlpha &gt; 0.25
    gameoverAlpha-= 0.005
  }

diffleft = glass.pp - pp
diffright = -diffleft
if diffleft &gt; diffright {
  clleft = c_lime
  clright = c_red
  }
else if diffright &gt; diffleft {
  clleft = c_red
  clright = c_lime
  }
else {
  clleft = 0
  clright = 0
  }
diffleft = abs(diffleft)
diffright = abs(diffright)

if lineanim {
  animdelay--
  if animdelay &lt; 0
    animdelay = 4
  else
    exit
  for (var i=0; i&lt;burn; i++) {
    arr[burnList[i], lineanimtick] = 0
    arr[burnList[i], 9-lineanimtick] = 0
    }
  lineanimtick++
  if lineanimtick == 5 {
    for (var i=0; i&lt;burn; i++) {
      for (var h=burnList[i]; h&gt;0; h--) {
        for (var j=0; j&lt;10; j++) {
          arr[h,j] = arr[h-1,j]
          }
        }
      for (var j=0; j&lt;10; j++)
        arr[0,j] = 0
      }
    lineanimtick = 0;
    lineanim = false
    tetrisanim = false
    burn = 0
    burnList = 0
    }
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>eid = ds_map_find_value(async_load, "id");
type = ds_map_find_value(async_load, "type");
sock = ds_map_find_value(async_load, "socket");
ip = ds_map_find_value(async_load, "ip");
msg_buff = ds_map_find_value(async_load, "buffer");

if type = network_type_data {
  var header = buffer_read(msg_buff, buffer_s8)
  switch header {
    case 1:
      global.plright = buffer_read(msg_buff, buffer_string)
      break
    case 11:  //shift
      currX = buffer_read(msg_buff, buffer_s8)
      break
    case 12:  //gravity
      currH = buffer_read(msg_buff, buffer_s8)
      break
    case 13:  //rot
      fx[0] = buffer_read(msg_buff, buffer_s8)
      fx[1] = buffer_read(msg_buff, buffer_s8)
      fx[2] = buffer_read(msg_buff, buffer_s8)
      fx[3] = buffer_read(msg_buff, buffer_s8)
      fh[0] = buffer_read(msg_buff, buffer_s8)
      fh[1] = buffer_read(msg_buff, buffer_s8)
      fh[2] = buffer_read(msg_buff, buffer_s8)
      fh[3] = buffer_read(msg_buff, buffer_s8)
      break
    case 14:  //next
      if nextFig == "I"
        dry = 0
      else {
        dry++
        if dry &gt; maxdry
          maxdry = dry
        }
      currX = buffer_read(msg_buff, buffer_s8)
      currH = buffer_read(msg_buff, buffer_s8)
      fx[0] = buffer_read(msg_buff, buffer_s8)
      fx[1] = buffer_read(msg_buff, buffer_s8)
      fx[2] = buffer_read(msg_buff, buffer_s8)
      fx[3] = buffer_read(msg_buff, buffer_s8)
      fh[0] = buffer_read(msg_buff, buffer_s8)
      fh[1] = buffer_read(msg_buff, buffer_s8)
      fh[2] = buffer_read(msg_buff, buffer_s8)
      fh[3] = buffer_read(msg_buff, buffer_s8)
      currClr = buffer_read(msg_buff, buffer_u32)
      gameover = buffer_read(msg_buff, buffer_bool)
      sequencePosition++
      nextFig = string_char_at(sequence, sequencePosition+1)
      break
    case 15:  //fixate
      pp = buffer_read(msg_buff, buffer_s32)
      lines = buffer_read(msg_buff, buffer_s16)
      ttrpercent = buffer_read(msg_buff, buffer_s8)
      level = buffer_read(msg_buff, buffer_s8)
      gameover = buffer_read(msg_buff, buffer_bool)
      clmod = (lines div 10)*8
      // safety checks (OoB placement)
      // vertical axis checks
      var missplacement = false
      for (var i=0; i&lt;4; i++)
        if fh[i] + currH &gt;= 20
          missplacement = true
      // horisontal axis checks (game potentially can crash without this check)
      for (var i=0; i&lt;4; i++)
        if (fx[i] + currX &lt; 0) || (fx[i] + currX &gt;= 10)
          missplacement = true
      //fixate (&amp; additional safety check for occupied cells)
      if (!missplacement) {
        for (var i=0; i&lt;4; i++) {
          var tempH = fh[i]+currH
          if (tempH &lt; 0)
            continue
          if arr[tempH, fx[i]+currX] != 0
            missplacement = true
          arr[tempH, fx[i]+currX] = currClr
          }
        }
      //request synch
      if missplacement {
        buffer_seek(global.buffer, buffer_seek_start, 0);
        buffer_write(global.buffer, buffer_s8, 16)
        network_send_packet( global.botnet, global.buffer, buffer_tell(global.buffer) );
        }
      //burn lines
      burn = 0
      burnList = 0
      for (var i=0; i&lt;4; i++) {
        var tempH = fh[i]+currH
        if tempH &lt; 0
          continue
        var add = true
        for (var j=0; j&lt;burn; j++) {
          if tempH == burnList[j] {
            add = false
            break
            }
          }
        if add {
          var rowFilled = true
          for (var j=0; j&lt;10; j++)
            if arr[tempH,j] == 0 {
              rowFilled = false
              break
              }
          if rowFilled {
            burnList[burn] = tempH
            burn++
            }
          }
        }
      currH = -2
      //sort droplines
      if burn &gt; 1 {
        for (var j=0; j&lt;3; j++)
          for (var i=0; i&lt;burn-1; i++)
            if burnList[i] &gt; burnList[i+1] {
              var ext = burnList[i];
              burnList[i] = burnList[i+1]
              burnList[i+1] = ext
              }
        }
      //burn lines
      if burn &gt; 0 {
        if burn == 4 {
          tetrisanim = true
          }
        lineanim = true
        }
      break
    case 16:
      oAdapterSynchReq()
      break
    case 17:
      oAdapterSynchRecv()
      break
    case 19:  //restart
      global.seed = string(random_get_seed() + 1)
      room_restart()
      break
    }
  }
else if type = network_type_disconnect {
  gameover = true
  global.adapter = false
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if tetrisanim {
  draw_set_alpha(random(0.7))
  draw_set_color(c_white)
  draw_rectangle(640,0,1024,672,false)
  }

//draw locked figures
var xl = xLeft2 + 32;
for (var i=0; i&lt;20; i++)
  for (var j=0; j&lt;10; j++)
    if arr[i,j] != 0
      draw_sprite_ext(sTile,0,xl+j*32,i*32,1,1,0,arr[i,j],gameoverAlpha)
      
//draw current figure
for (var i=0; i&lt;4; i++)
  draw_sprite_ext(sTile,0,xl+(currX+fx[i])*32, (currH+fh[i])*32, 1,1,0,currClr,gameoverAlpha)
  
//draw next figure
if nextFig != ""
  switch nextFig {
    case "I": draw_sprite_ext(sprite1,0,1097,85,1,1,0,c_white,1); break
    case "S": draw_sprite_ext(sprite1,1,1097,85,1,1,0,make_color_hsv(42+clmod,255,255),1); break
    case "Z": draw_sprite_ext(sprite1,2,1097,85,1,1,0,make_color_hsv(213+clmod,255,255),1); break
    case "O": draw_sprite_ext(sprite1,3,1097,85,1,1,0,make_color_hsv(128+clmod,255,255),1); break
    case "T": draw_sprite_ext(sprite1,4,1097,85,1,1,0,make_color_hsv(clmod, 255,255),1); break
    case "L": draw_sprite_ext(sprite1,5,1097,85,1,1,0,make_color_hsv(85+clmod, 255,255),1); break
    case "J": draw_sprite_ext(sprite1,6,1097,85,1,1,0,make_color_hsv(170+clmod,255,255),1); break
    }  

// Opponent's stats
draw_set_font(fTetris)
draw_set_color(c_white)
draw_set_halign(fa_left)
draw_set_valign(fa_top)
draw_set_alpha(1)
draw_text(1040, 10, "NEXT:")
draw_text(1040, 125, "SCORE:#"+string(pp))
draw_text(1040, 255, "LINES:#"+string(lines))
draw_text(1040, 330, "LEVEL:#"+string(level))
draw_text(1040, 445, "DRY/MAX:#"+string(dry)+" / "+string(maxdry))
draw_text(1040, 525, "TTR:#"+string(ttrpercent))
draw_text_transformed(1040,682,"FIG "+string(sequencePosition),0.4,0.4,0)

// Score differences
draw_set_color(clright)
draw_text(1040,200, string(diffright))
draw_set_halign(fa_right)
draw_set_color(clleft)
draw_text(240,200, string(diffleft))

// Names
draw_set_color(c_white)
draw_text(600,675,global.plleft)
draw_set_halign(fa_left)
draw_text(680,675,global.plright)
draw_set_halign(fa_center)
draw_text_transformed(640,685, "VS", 0.6,0.6, 0)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
